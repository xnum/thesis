\documentclass[12pt,a4paper,oneside]{book}

\usepackage[titletoc]{appendix}
\usepackage{subfigure}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{epsfig}
% border setting
\usepackage[ top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm ]{ geometry }

% The default for LaTeX is to have no indent after sectional headings, like \chapter and \section. ()
\usepackage{indentfirst}

% http://tex.stackexchange.com/questions/28333/continuous-v-per-chapter-section-numbering-of-figures-tables-and-other-docume
\usepackage{chngcntr}
\counterwithout{figure}{chapter}
\counterwithout{table}{chapter}

% This prevents placing floats before a section
\usepackage[section]{placeins}
\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

% source code hightlighting
\usepackage{listings}
\lstset{
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  captionpos=b,
  tabsize=2,
  basicstyle=\small,
  numberfirstline=true
}

% setting the page number to footer
\usepackage{fancyhdr}
\fancyhf{}
\cfoot{\thepage}
\pagestyle{fancy}
% no header and footer bar
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% setup bibliography
\usepackage[sorting=none,backend=bibtex]{biblatex}
\addbibresource{reference.bib}

% line height setting
\linespread{1.5}
\usepackage{setspace}

% Graphics settings
\usepackage{graphicx}
\graphicspath{ {./figures/} }

\usepackage{background}
\newcommand\DeactivateBG{\backgroundsetup{contents={}}}
\newcommand\ActivateBG{
  \backgroundsetup{
      contents={\includegraphics[]{logo.jpg}},
      scale=1,
      opacity=0.4,
      angle=0
  }
}

\usepackage{comment}

% do not place figure at the middle of a empty page
\makeatletter
\setlength{\@fptop}{0pt}
\makeatother

% Chinese typesetting
\usepackage{xeCJK}
%\setCJKmainfont{SourceHanSansTW-Light.otf}
\setCJKmainfont[
  BoldFont={SourceHanSansTW-Normal.otf},
  ItalicFont={SourceHanSansTW-Light.otf}
]{SourceHanSansTW-Light.otf}
\newcommand{\myHuge}[1]{\fontsize{40}{50} #1}

\newcommand{\chineseTitle}{基於蒙地卡羅樹搜尋法之路徑探索於符號執行}
\newcommand{\englishTitle}{MCTS-based Path Exploration for Symbolic Execution}

\newcommand{\studentCnName}{葉家郡}
\newcommand{\studentEnName}{Jia-Jun Yeh}
\newcommand{\advisorCnName}{黃世昆}
\newcommand{\advisorEnName}{Shih-Kun Huang}

\usepackage{pdfpages}
\DeclareMathOperator*{\argmax}{arg\,max}
\begin{document}

\pagenumbering{gobble} % disabling page numbering

\ActivateBG

\input{cover1.tex}
\input{cover2.tex}

\DeactivateBG

% 放審定書和授權書
% \includepdf[pages={1-2}]{auth.pdf}

\ActivateBG

\input{abstract_chinese.tex}
\input{abstract_english.tex}

\tableofcontents
\listoffigures
\listoftables

\chapter{Introduction} \pagenumbering{arabic} % enabling page numbering

在現今的軟體開發中，程式碼數量動輒數萬行，系統的複雜度也越來越高，傳統驗證程式正確性的方式如unit testing、code review等等...受限於人工而相當有限。在硬體計算能力突飛猛進的現代，自動化測試的方式又逐漸成為顯學，如fuzzing、symbolic execution...能夠自動尋找程式中可能的漏洞，其中symbolic execution是一種模擬執行的方法，它將程式的使用者輸入視為符號，並把程式執行過程和分支條件轉換為限制式，藉由求解限制式來獲得欲執行該路徑所需的使用者輸入為何；由於symbolic execution在遇到分支時會複製出一條新的路徑，兩條路徑分別探索執行if時和執行else時的狀態，因此路徑數量會以指數的數量級成長，記錄並運算這些路徑需要花費巨大的電腦資源，這個問題被稱為path explosion problem，這篇論文欲以蒙地卡羅樹搜尋演算法來找出探索價值較高的路徑，使得symbolic execution能使用較短的時間內獲得更高的程式執行覆蓋率。

蒙地卡羅樹搜尋(Monte Carlo tree search)被廣泛的運用在遊戲人工智慧中，例如西洋棋、黑白棋、圍棋等等的棋盤遊戲，在2016年AlphaGo \cite{alphago}(一個結合蒙地卡羅樹搜尋和深度學習的圍棋AI程式)擊敗世界棋王後，更是一度引起相當多的討論。此演算法主要的精神在於：對一棵空間狀態樹，如何選擇節點，並以模擬的方式推估該節點的可能發展狀況和價值，藉由不斷的重複此動作來逼近最佳解。和symbolic execution相當類似的地方在於同為需要探索一棵樹，而且要避免探索一些我們不感興趣或是沒有必要探索的路徑；我們認為結合蒙地卡羅樹搜尋做為symbolic execution挑選路徑執行的演算法，相較於傳統的深度優先搜尋法或廣度優先搜尋法，能有較佳的搜尋效率。


\chapter{Background}

在這個章節將簡要介紹symbolic execution與其遇到的問題，還有蒙地卡羅樹搜尋演算法的計算流程。

\section{Symbolic execution}

% 說明symbolic execution的流程和精神
在本篇論文中所提及的symbolic execution屬於Dynamic symbolic execution，首先由K. Sen\cite{sen2007concolic}提出，和基於其想法實作的程式DART\cite{godefroid2005dart}、CUTE\cite{sen2005cute}，而其近年又分為兩種類型：需要程式原始碼的code-based symbolic execution如KLEE\cite{cadar2008klee}，和不須程式碼而直接分析程式執行檔的binary-based symbolic execution如S2E\cite{chipounov2012s2e}、Mayhem\cite{cha2012mayhem}。symbolic execution engine在分析程式時會將其載入並先轉換為intermediate representation (IR)，接著會將使用者輸入(例如標準輸入、檔案、命令列參數)標記為symbolic變數，接著模擬程式的執行過程，將執行過程中遇到的程式碼轉換為數學邏輯限制式的形式，當在模擬的過程中遇到分支條件時，便複製出一條新的路徑，分別追蹤該分支條件為真和為假時的情況；當模擬執行結束時，把先前蒐集的邏輯限制式利用solver求解(如：SMT\cite{vanegue2012smt}、Z3\cite{Z3}等等)，以取得欲執行該路徑所需的實際輸入值；透過這個流程理論上我們可以追蹤所有的執行路徑，探索是否有不當的輸入值能觸發程式崩潰。

如下Figure \ref{figSE}為一個簡單的binary-based symbolic execution執行時的狀況，它會依序讀入並根據指令進行相對應的模擬，位址4004f1將一個標記為symbolic variable的位址載入到暫存器eax中，則symbolic execution engine會在constraint table中標記eax為sym\_var1；4004f8將eax加3，symbolic execution engine則會在constraint table中記錄eax加3。當讀到比較而且需要跳轉的指令時，如果無法決定該執行哪個分支，如Figure \ref{figSE}中因為eax是由symbolic variable所決定的，當使用者輸入的是不同數值，將導致不同的分支被執行，因此symbolic execution engine需要分別追蹤該分支為真和假時的狀態；由於每執行一條指令就返回顯得十分沒有效率，通常會讓symbolic execution engine遇到跳轉指令時，處理完狀態複製再返回，這樣的流程我們將其稱為一個步驟(step)。

\begin{figure}[htbp]
\center
\includegraphics[width=\textwidth]{figures/SE.PNG}
\caption{symbolic execution流程 \label{figSE}}
\end{figure}

% 說明symbolic execution中的路徑探索問題
雖然symbolic execution理論上能夠探索所有執行路徑，但在探索的過程中可能會遭遇到一些問題：當分支條件取決於symbolic variable時，很有可能兩邊的條件都有可能成立，這意謂著程式必須複製並分別維護兩條路徑，直到發現路徑無解為止，當路徑被不斷的複製，就產生了路徑爆炸問題(path explosion problem)。

\section{Monte Carlo tree search}

MCTS是一種啟發式搜尋演算法，近年來最廣為人知的應用是遊戲AI方面的演算法；Monte Carlo模擬是利用模擬和統計，得到一個近似解，在足夠大量的模擬下，理論上我們可以得到一個跟最佳解非常接近的答案。MCTS套用了這種模擬的方式，維護一棵樹(在遊戲AI中通常是一個遊戲盤面的狀態樹)並統計每個盤面的勝率，期望能只探索部分的樹，而非全部探索完的情況下，就能知道該盤面的勝率。

在\cite{browne2012surveyMCTS}中說明了MCTS演算法的基本流程，如Figure \ref{figMCTS}：

\begin{figure}[h]
\center
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{figures/mcts2.PNG}
\caption{Monte Carlo Tree Search \label{figMCTS}}
\end{figure}

\begin{itemize}
\item \textbf{Selection} 根據設定的\textit{Tree Policy}，從根節點開始遞迴性的決定一個目前最需要展開的節點，如Figure \ref{figMCTS}中的Selection部分，以粗框標記出的節點。可展開的節點在這裡定義為狀態尚未終止且有尚未訪問的子節點。
\item \textbf{Expansion} 在選擇的節點上，執行一個合法的動作來新增子節點，如Figure \ref{figMCTS}中的Expansion部分，在挑選的節點下新增一個節點。
\item \textbf{Simulation} 從這個新增的節點上使用\textit{Default Policy}來進行模擬執行，產生結果。
\item \textbf{Backpropagation} 模擬的結果會回饋到步驟1所選擇路過的那些節點上，更新他們的統計數據。
\end{itemize}

在這邊有兩個policy：\textit{Tree Policy}代表的是如何決定要選擇和新增節點的演算法。\textit{Default Policy}則是如何從該節點的狀態模擬對局直到獲得勝負結果。雖然這兩個Policy也可以簡單的使用隨機方式決定，但適當的演算法有助於強化MCTS的準確度，如\cite{Intro2MCTS}便指出，\textit{Tree Policy}可以使用upper confidence bound (UCB)演算法來取代隨機挑選，如果我們把盤面的位置當成吃角子老虎機，視為multi-armed bandit problem來處理的話，會比原本的隨機選擇好；另外他也指出模擬時除了用這些簡單的方法，也可以使用更耗費資源的啟發式邏輯和評價方式，在對於higher branching factor的遊戲會有較好的效果。

\chapter{Method}

\section{Motivation example}

在不同策略下，樹的走訪順序如Firuge \ref{figST}所示，假設固定先選擇的都是左子樹，DFS會優先選擇最深的節點來走訪，而BFS選擇最淺的節點，這兩個策略都有一樣的問題：順序是固定的，如DFS很可能因為左子樹太過龐大，但較高效益的節點在右子樹，而浪費很多時間在走訪較低效益的節點；又如BFS，很可能較高效益的節點要往深處搜尋，但走訪深度較淺的節點就已經花費不少時間。它們共同的問題就是走訪到節點5、6的順序都一樣是在最後面。而MCTS的走訪順序是不固定的，它會動態的選擇一個被認為是目前最應該走訪的節點來進行計算。

\begin{figure}[htbp]
\center
\includegraphics[width=\textwidth]{figures/strategy.PNG}
\caption{不同策略的樹走訪順序 \label{figST}}
\end{figure}

Figure \ref{figTREE}為範例程式碼Algorithm 1在symbolic execution計算過程中所建立的狀態樹，每個節點都代表著一個狀態，包含了程式的暫存器和記憶體內容，symbolic variables的constraint等等。root節點代表剛進入該段程式的狀態，而其左子節點則是執行完第1行時的狀態，我們以數字1來標記該節點目前執行的位址，沒有標記數字的節點則是代表程式結束，其他節點也以此類推。

\begin{figure}[htbp]
\center
\includegraphics[width=\textwidth]{figures/tree.png}
\caption{Tree of the example code \label{figTREE}}
\end{figure}

從Figure \ref{figTREE}這棵樹中我們可以發現，當使用DFS來進行搜索時，程式需要先走訪完整個左子樹才有可能執行到bug函式，更壞的情況是有可能左子樹大到無法走完，程式被困在其中進行無效的運算；而如果使用BFS來搜索時，雖然最後foo函式和bug函式會在差不多的時間點被執行到，但很有可能因為在過程中已經發現太多節點，而造成記憶體空間不足的問題；所以我們希望採用一個策略，是程式能動態決定該選擇哪個節點來往下走訪的。

\newpage

\begin{algorithm}[htbp]
  \caption{Example Code}
  \begin{algorithmic}[1]
    \If{$w>5$}
    	\If{$x>10$}
        	\If{$y>20$}
            	\If{$z>30$}
                	\State foo()
                \EndIf
            \EndIf
        \EndIf
    \Else
        \If{$x>10$}
        	\If{$y>20$}
            	\If{$z>30$}
                	\State bug()
                \EndIf
            \EndIf
        \EndIf
    \EndIf
  \end{algorithmic}
\end{algorithm}

對symbolic execution而言，不管採用哪種搜尋策略，我們的目標都是：如何達到更高的程式碼覆蓋率，以盡可能的測試出不同執行狀態時，程式是否會發生錯誤或崩潰。我們希望採用MCTS演算法來搜索時，能比傳統的搜尋方法能在同樣的資源限制下(如時間限制、記憶體限制)走訪更多的程式碼。

\section{proposed algorithm}

\begin{algorithm}[htbp]
  \caption{applying MCTS algorithm to symbolic execution}
  \begin{algorithmic}[1]
  	\Function{Search}{$p_r$}
    \State set $p_r$ as root of Tree $T$
    \State $B \leftarrow \emptyset$
    \While {within computational budget}
      \State $p$ $\leftarrow$ TreePolicy($T$)
      \State $B \leftarrow B \bigcup p$
      \State $S$ $\leftarrow$ step($p$)
      \For{each path $p_c \in S$}
      	\State $V \leftarrow$ DefaultPolicy($p_c$)
        \State $Q(p_c) \leftarrow \alpha \frac{|V-B|}{N} + \beta|p_c|$
        \State add a new child $p_c$ to $p$
      \EndFor
      \State BackPropagation($p$)
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Algorithm 2 為我們設計的演算法主體。$p_r$為現在要搜尋的路徑，首先將$p_r$設為樹$T$的root，以記錄路徑間的關係，並以集合$B$來計算路徑走訪的數量。在第5行我們會先利用\textit{Tree Policy}從樹$T$中挑選一個應該計算的路徑$p$，並將$p$加進集合$B$中(路徑$p$事實上可以被視為是數個走訪過的位址集合)，接著將$p$遞交給symbolic execution engine進行計算，symbolic execution engine會將這條路徑step(往下執行若干條指令，直到遇見分支跳轉指令才停止)；step後可能產生數條路徑，我們以集合$S$來表示，$S$中的路徑代表$p$ step後可能的狀態，如執行if時或執行else時的狀態，遇到switch case時執行不同case的狀態；在第8行對$S$中的每條路徑$p_c$我們都會利用\textit{Default Policy}來模擬其未來可能的走向，並評估此路徑的價值$Q(p_c)$，將$p_c$標記為$p$的child；最後在第13行整理先前第8-12行的資訊並記錄起來。

在第10行為我們計算路徑價值的公式，此公式分為兩個部分，其中$\alpha$、$\beta$和$N$為可以人為控制的參數。$\frac{|V-B|}{N}$中的$V$為路徑$p_c$經由\textit{Default Policy}計算後得出未來可能會執行的位址集合，和集合$B$取差集後計算其數量，除以$N$(\textit{Default Policy}模擬的次數)就是路徑$p_c$增加程式執行區塊覆蓋率的期望值；而$|p_c|$為$p_c$執行過的程式碼區塊數量，這個參數是為了在所有路徑的覆蓋率期望值都非常低的時候，能優先選擇較深的路徑避免進行無謂的探索。$\alpha$和$\beta$是這兩個數值的權重。計算$Q$時的$\alpha$主要控制的是增加覆蓋率的期望值，由於路徑的模擬是根據Control flow graph(CFG)來猜測，如果產生的CFG不正確(不同的實作方式可能產生不同結果)或程式的實際執行狀況和模擬的結果有落差，期望值就會變得不準確，相對的對於簡單的小程式，模擬的準確度有可能是較高的，因此適當的調整$\alpha$可以修正模擬的數據；而$\beta$是為了因應遇到大量迴圈或strcmp這類函式的措施，由於進入迴圈容易產生大量的分枝，會讓path數量一下子成長很多，\textit{Tree Policy}在選擇時也容易被混淆，我們透過計算該path已經執行過的程式碼區塊數量，讓演算法在挑選時偏好已經執行比較多區塊數量的路徑。

Algorithm 3是Algorithm 2中所提及的函式實作部分。\textit{Tree Policy}用來挑選應該被計算的路徑，而價值計算事實上是由$BestChild$決定，其中的一個參數$C$，其影響的是MCTS中最大的特徵：expolitation和exploration，也就是程式該往較深的點進行計算，還是選擇較少被計算過的點，不過這個數值在branching factor高時較有效，而我們產生出的path常常只有1至2個，所以這個參數的影響並不大，唯一會影響的是當某個節點尚未被計算過任何一次的時候，$N(p_c)$為0，根號內的數值會是無限大，程式就一定會選擇該節點來進行計算。\textit{Default Policy}的參數$N,M$，$N$是要進行幾次模擬，而$M$是避免程式進入無窮迴圈，當到達一定數字時會強制中斷模擬，對於較小的程式可以選擇較小的數字，而較複雜的程式可以選擇比較大的數字來增加其準確性，但也相對的花費更多時間。$BackPropagation$會更新兩項數值，$N(v)$為$v$被訪問的次數，對於價值$Q(v)$則以$v$的子節點們的平均來替代。

\begin{algorithm}[H]
  \caption{Policies for our algorithm}
  \begin{algorithmic}[]
    \Function{TreePolicy}{$T$}
    	\State $n \leftarrow$ root of $T$
        \While {$n$ is not terminated}
        	\If{$n$ is expandable}
            	\State \Return {$n$}
            \Else
            	\State $n \leftarrow BestChild(n,C)$
            \EndIf
        \EndWhile
    \EndFunction
    \item[]
	\Function{DefaultPolicy}{$p$}
    	\State $V \leftarrow \emptyset$
        \For{$i=1$; $i<N$; $i++$}
          \State $v \leftarrow$ find vertex at CFG($p$'s addr)
          \For{$j=1$; ($j<M$)and($v$ has any edge); $j++$}
              \State add $v$ to $V$
              \State $v \leftarrow$ random pick a vertex which $v$ directed to
          \EndFor
        \EndFor
        \State \Return $V$
    \EndFunction
    \item[]
    \Function{BestChild}{$p,C$}
    	\State $Q_{max} \leftarrow \operatorname*{arg\,max}_{p_c \in p} Q(p_c)$
    	\State \[ \Return \argmax_{p_c \in p} \frac{Q(p_c)}{Q_{max}}+C\sqrt[]{\frac{2\ln N(p)}{N(p_c)}} \]
    \EndFunction
    \item[]
    \Function{BackPropagation}{$v$}
    \While{$v$ is not null}
    	\State N($v$) += 1
		\State Q($v$) $\leftarrow$ average of Q($v$'s children)
    \State $v \leftarrow$ parent of $v$
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\section{algorithm explanation}

如下Figure \ref{figStep} 為MCTS簡要的執行過程示意圖。在Step 1設定根節點後，由於沒有任何子節點，我們在Selection階段便直接選擇根節點，進行Expansion後新增兩個子節點，其價值經Simulation計算後分別為60和80。Step 2從根節點找到兩個子節點，在這邊選擇價值為80的子節點進行Expansion，得到兩個子節點並計算出其價值為50和52，獲得子節點的估計價值後，便可以作為Backpropagation使用，節點1的價值將改由其子節點價值的平均來取代，如這邊即從80變為51。Step 3因為在Step 2時修正了節點1的價值，在Selection階段便會轉而選擇節點2，經過Expansion和Simulation後同樣利用子節點來修正節點2的價值，不斷的重複這個步驟來挑選最應該被計算的節點。

\begin{figure}[htbp]
\center
\includegraphics[width=\textwidth]{figures/step.PNG}
\caption{MCTS執行過程 \label{figStep}}
\end{figure}

\chapter{Result and Evaluation}

\section{Environment}

我們將本篇論文提出的演算法實作於Angr (一個開源的python符號執行框架) \cite{angr}上，並在Ubuntu 16.04作業系統環境進行實驗，受測程式如Table \ref{binarys}。硬體環境使用的是Intel i7-2600k處理器以及24 GB記憶體。主要比較的目標是演算法經由symbolic execution所執行過的程式碼區塊數量：程式碼區塊指的是一段程式碼中間沒有任何的跳轉指令，而以跳轉指令為結尾，也就是說程式碼區塊執行直到最後一個指令時才會跳轉到其他區塊，每個區塊都不會發生與其他區塊有所重疊或覆蓋的情形；我們以程式碼區塊的第一條指令位址為其開始位址並作為判斷是否重複的標準，對重複執行過的區塊我們只會計算一次而不是會重複計算多次。在前章所提及的演算法參數，由於參數調校並非本篇論文的重點，因此在所有實驗中都固定使用同一組參數來進行。

\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}
\begin{table*}[htbp]\centering
\caption{Target Program's name and version}
\label{binarys}
\begin{tabular}{@{}ll@{}}\toprule
program name & version \\ \midrule
cp           & 8.25    \\ 
echo         & 8.25    \\ 
hostname     & 3.16    \\ 
ls           & 8.25    \\ 
mkdir        & 8.25    \\ 
ps           & 3.3.10  \\ 
readelf      & 2.26.1  \\ 
touch        & 8.25    \\ 
cpp-markdown & 1.00    \\ 
gif2png      & 2.5.8   \\ \bottomrule
\end{tabular}
\end{table*}

\section{演算法與其他方法的比較}

% 3k step, BFS, DFS, MCTS
為了比較不同方法間的效率好壞，我們給定一個資源限制：程式最多只能使用symbolic execution engine來step 3000次，對時間和記憶體用量皆未限制。Table \ref{testMethod}是在此限制下MCTS和DFS、BFS比較的結果。其中數量為前一節所述的程式碼區塊數量，時間為該次實驗的執行時間(秒)，效率則是區塊數量除以時間後得到每秒會增加的平均值。單以區塊數量來看MCTS的總和勝過其他兩種方法，雖然不同方法在不同程式上各有需要耗費較多時間的狀況，但平均來說MCTS的效率仍然高於其他兩種方法。

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{不同方法的效率比較}
\label{testMethod}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{MCTS} & \phantom{abc} & \multicolumn{3}{c}{DFS} & \phantom{abc} & \multicolumn{3}{c}{BFS} \\ \cmidrule{2-4} \cmidrule{6-8} \cmidrule{10-12}
program      & 數量   & 時間   & 效率   & & 數量   & 時間   & 效率   & & 數量    & 時間   & 效率      \\ \midrule
cpp-markdown & 566    & 272.07 & 2.08 & & 529    & 306.27& 1.73  & & 478     & 318.16 & 1.50   \\
cp           & 388    & 3732.45& 0.10 & & 218    &2340.34& 0.09  & & 174     & 326.38 & 0.53   \\
echo         &  84    & 164.90 & 0.51 & &  76    & 283.49& 0.27  & &  83     & 126.61 & 0.66   \\
gif2png      & 105    & 192.66 & 0.55 & &  64    &2115.42& 0.03  & &  59     & 680.98 & 0.09   \\ 
hostname     & 175    & 277.80 & 0.63 & &  62    & 147.08& 0.42  & &  61     & 309.11 & 0.20   \\
ls           & 393    & 715.55 & 0.55 & & 189    &1053.82& 0.18  & & 152     &3057.35 & 0.05   \\
mkdir        & 320    & 275.96 & 1.16 & &  82    & 142.86& 0.57  & & 119     & 198.10 & 0.60   \\
ps           &  99    & 682.35 & 0.15 & & 185    & 176.52& 1.05  & & 109     &1083.84 & 0.10   \\
readelf      & 288    & 870.36 & 0.33 & & 393    & 913.68& 0.43  & & 156     &1179.49 & 0.13   \\
touch        & 302    & 331.78 & 0.91 & & 213    &1665.38& 0.13  & & 124     & 194.40 & 0.64   \\ \hline
平均          & 495    &1366.52 & 1.27 & & 366    & 1662.7& 0.89  & & 275     & 1358.99 & 0.81 \\
標準差        & 718    &2174.55 & 1.88 & & 539    & 2488.82& 1.35 & & 407     & 2095.99 & 1.23 \\ \bottomrule
% sum          & 2720   & 7515.88& 6.96 & & 2011   &9144.86& 4.90  & & 1515    &7474.42 & 4.50   \\ \bottomrule
\end{tabular}
\end{table}

\section{長時間執行的效率比較}

% 24hr + 20G limit (usually 50k~100k step), BFS, DFS, MCTS
經小規模實驗得到MCTS較佳的結果後，我們用較大規模的方法來實驗，前項實驗的執行時間大約為15分鐘上下，且記憶體用量幾乎不會超過2 GB；因此在這個實驗我們改以24小時的時間限制和20 GB的記憶體用量限制，而不限制其在symbolic execution engine的step次數，來觀察在有限的記憶體用量下，我們的方法相較於傳統的方法能有多少幅度的效率成長。

%%%%%%%%%%%%%%%%%
% cpp-markdown
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={cpp-markdown},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=100000,
    ymin=0, ymax=800,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000,100000},
    ytick={0,100,200,300,400,500,600,700,800},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,47)(500,199)(1000,349)(2000,477)(5000,541)(10000,559)(20000,593)(100000,606)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,47)(500,205)(1000,376)(2000,497)(5000,572)(10000,579)(20000,579)(100000,588)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,47)(500,196)(1000,385)(2000,459)(5000,519)(10000,560)(20000,629)(100000,661)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for cpp-markdown \label{test_cpp-markdown}}
\end{figure}

%%%%%%%%%%%%%%%%%
% cp
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={cp},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=700,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,100,200,300,400,500,600,700},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,38)(500,119)(1000,202)(2000,331)(5000,462)(10000,573)(17000,581)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,47)(500,164)(1000,178)(2000,186)(5000,222)(10000,222)(20000,222)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,24)(500,50)(1000,92)(2000,126)(5000,196)(10000,215)(20000,226)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for cp \label{test_cp}}
\end{figure}

%%%%%%%%%%%%%%%%%
% echo
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={echo},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=150,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,20,40,60,80,100,120,140},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,37)(500,67)(1000,71)(2000,79)(5000,92)(10000,93)(20000,102)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,34)(500,52)(1000,57)(2000,71)(5000,84)(10000,87)(20000,87)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,27)(500,43)(1000,57)(2000,77)(5000,105)(10000,118)(20000,129)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for echo \label{test_echo}}
\end{figure}

%%%%%%%%%%%%%%%%%
% gif2png
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={gif2png},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=150,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,20,40,60,80,100,120,140},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,26)(500,70)(1000,96)(2000,107)(5000,107)(10000,107)(20000,107)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,14)(500,34)(1000,64)(2000,64)(5000,64)(10000,64)(20000,64)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,23)(500,49)(1000,53)(2000,58)(5000,61)(10000,63)(20000,73)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for gif2png \label{test_gif2png}}
\end{figure}

%%%%%%%%%%%%%%%%%
% hostname
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={hostname},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=200,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,40,80,120,160,200},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,25)(500,95)(1000,128)(2000,146)(5000,184)(10000,184)(20000,184)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,35)(500,61)(1000,61)(2000,61)(5000,61)(10000,61)(20000,61)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,19)(500,57)(1000,60)(2000,61)(5000,63)(10000,64)(20000,65)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for hostname \label{test_hostname}}
\end{figure}


%%%%%%%%%%%%%%%%%
% ls
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={ls},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=700,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,100,200,300,400,500,600,700},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,35)(500,128)(1000,169)(2000,241)(5000,344)(10000,493)(20000,646)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,44)(500,125)(1000,156)(2000,158)(5000,198)(10000,198)(20000,198)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,38)(500,74)(1000,98)(2000,133)(5000,185)(10000,201)(12700,209)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for ls \label{test_ls}}
\end{figure}


%%%%%%%%%%%%%%%%%
% mkdir
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={mkdir},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=700,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,100,200,300,400,500,600,700},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,40)(500,96)(1000,97)(2000,120)(5000,389)(10000,532)(20000,568)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,49)(500,71)(1000,79)(2000,82)(5000,82)(10000,82)(20000,82)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,24)(500,76)(1000,95)(2000,110)(5000,126)(10000,133)(20000,154)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for mkdir \label{test_mkdir}}
\end{figure}

%%%%%%%%%%%%%%%%%
% ps
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={ps},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=20000,
    ymin=0, ymax=500,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000},
    ytick={0,100,200,300,400,500},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,29)(500,72)(1000,83)(2000,96)(5000,107)(10000,271)(15600,431)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,27)(500,118)(1000,185)(2000,185)(5000,185)(10000,185)(20000,185)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,32)(500,55)(1000,84)(2000,107)(5000,116)(10000,128)(11600,131)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for ps \label{test_ps}}
\end{figure}

%%%%%%%%%%%%%%%%%
% readelf
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={readelf},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=90000,
    ymin=0, ymax=700,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000,80000},
    ytick={0,100,200,300,400,500,600,700},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,43)(500,103)(1000,163)(2000,280)(5000,352)(10000,421)(20000,456)(90000,652)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,41)(500,124)(1000,234)(2000,323)(5000,393)(10000,415)(20000,464)(35800,466)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,39)(500,95)(1000,113)(2000,133)(5000,177)(10000,185)(20000,201)(22000,205)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for readelf \label{test_readelf}}
\end{figure}

%%%%%%%%%%%%%%%%%
% touch
%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\center
\begin{tikzpicture}
\begin{axis}[
    title={touch},
    xlabel={step times},
    ylabel={number of basic blocks coverage},
    xmin=0, xmax=100000,
    ymin=0, ymax=500,
    width=\textwidth,
    height=\textheight/2-3cm,
    xtick={0,100,500,1000,2000,5000,20000,100000},
    ytick={0,100,200,300,400,500},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmode=log,
    log ticks with fixed point,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (100,39)(500,141)(1000,218)(2000,286)(5000,307)(10000,334)(20000,339)(100000,340)
    };
    \addlegendentry{MCTS}

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {
    (100,48)(500,117)(1000,161)(2000,184)(5000,222)(10000,222)(20000,222)(65400,222)
    };
    \addlegendentry{DFS}

\addplot[
    color=green,
    mark=star,
    ]
    coordinates {
    (100,24)(500,71)(1000,91)(2000,116)(5000,142)(10000,161)(20000,175)(24700,182)
    };
    \addlegendentry{BFS}

\end{axis}
\end{tikzpicture}
\caption{large test for touch \label{test_touch}}
\end{figure}

\section{Discussions}

從個別的實驗數據中可以看到MCTS在面對不同程式所發揮的功用；伯仲之間的例子有Figure \ref{test_cpp-markdown}, \ref{test_echo}，成長情況不相上下，並沒有MCTS會完全弱於兩者的狀況。接著是DFS和BFS都會卡住不再成長而MCTS仍可繼續成長的情況：Figure \ref{test_cp}, \ref{test_gif2png}, \ref{test_hostname}, \ref{test_ls}, \ref{test_mkdir}，這也是在所有程式裡面占最多的例子，表示MCTS充分發揮了它的特性「exploitation and exploration」，當DFS和BFS分別在兩頭搜尋時，MCTS可以從中挑選較有價值的路徑來計算；最後是記憶體被耗盡的案例，如Figure \ref{test_ps}，DFS雖然較慢耗盡記憶體卻也沒有再挖掘到更多區塊，而BFS和MCTS都在差不多的地方耗盡了記憶體，MCTS卻能取得最好的結果，而Figure \ref{test_readelf}, \ref{test_touch}更凸顯出這一點，當DFS和BFS都已經被強制結束時，MCTS卻能找到更多區塊。

\chapter{Related Work}

\section{Path Selection Problem}

在\cite{sharma2012critical}\cite{schwartz2010all}中對symbolic execution所做的概述，提及了幾項目前的挑戰，其中一個重要的問題就是路徑選擇問題(path selection problem)，當路徑爆炸問題已難以避免其發生，我們希望藉由有效的路徑選擇在資源限制內做最高效率的探索；目前已經提出的幾種解決方式如：KLEE\cite{cadar2008klee}中提出的深度優先搜尋法來優先探索最深的路徑，但很有可能被困在無限迴圈而進行了無效的探索。\cite{sen2007concolic}提出的concolic testing，除了以symbolic execution執行，也會使用具體的輸入真正執行程式來蒐集執行路徑，\cite{sen2005cute}就使用了這種作法。而KLEE\cite{cadar2008klee}也支援隨機挑選路徑的方式來避免進行了無效的探索。

另外如driller\cite{stephens2016driller}結合了AFL\cite{AFL}的fuzzing技術，它將使用者輸入分類為需要特定值的特定輸入(specific input)和可接受各種數值的通用輸入(general input)，並透過symbolic execution engine和fuzzing engine的切換來解決各自不擅長的部分。而s2e\cite{chipounov2012s2e}則是利用選擇性的symbolic execution，避免連同其他函式庫也一起分析，造成路徑數量大量增長。另外也有針對路徑成長，檢查其可滿足性(satisfiability)並做動態剪枝的方法\cite{PathPruning}。

\section{MCTS and Game AI}

Monte Carlo方法是一種隨機取樣的方法，在1987年由Bruce Abramson提出\cite{mcmethod}。而在1989年，Monte Carlo tree search由W. Ertel, J. Schumann和C. Suttner提出，用來改善搜尋演算法的時間如DFS、BFS等等。而在1993年B. Brügmann首先將Monte Carlo方法用於圍棋上\cite{mc_go}，直到2006年這個方法才由Rémi Coulom真正被命名為Monte Carlo tree search\cite{MCTS_naming}。之後 L. Kocsis and Cs. Szepesvári以MCTS為基礎發表了upper confidence bound 1 applied to trees (UCT)演算法\cite {UCT}。在2015年由Google Deepmind研發的圍棋AI AlphaGo\cite{alphago}，使用MCTS和deep learning演算法，擊敗了人類職業選手，頓時之間AI和機器學習又成為電腦科學界的顯學。

由於遊戲盤面的推估複雜度與其盤面可呈現的狀態成正比，當一個盤面有數百種可能下法時，人類通常只考慮其中幾種並做深入的考量，相對於電腦而言如果全部展開盤面並計算顯得十分緩慢，因而程式設計師開始利用各種方法嘗試縮小真正需要的搜尋的那幾種可能；由程式設計師針對不同遊戲寫不同規則來應對，是一件不可能的事情，所以無論是MCTS或機器學習，皆在於讓電腦能自己掌握哪些情況是必須要計算，哪些情況則沒有必要的。

\chapter{Conclusion}

我們提出的演算法在實驗中證實，在相同的時間限制或資源限制下，比起傳統的DFS和BFS策略能有效的走訪更多程式碼，同樣在沒有修改任何程式或資料的情況下，我們額外使用一棵樹來記錄路徑的資訊和親子關係，就算沒有使用MCTS的方法，紀錄路徑間的親子關係也有可能用來作為其他演算法上的cut或pruning使用；唯一被修改的是路徑進入symbolic execution engine計算的順序，這使我們的方法與其他技術如concolic testing\cite{sen2007concolic}, veritesting\cite{Veritesting}, driller\cite{stephens2016driller}整合的難度有可能是變低的。

但我們的演算法仍然可能會有以下的問題，第一是路徑爆炸問題，如果我們完全不修剪路徑，它仍然可能發生，只能盡力在發生前挑選價值高的路徑進行搜索；如果借助我們建立的樹來進行修剪，雖然可以延緩甚至避免這個問題發生，但有些路徑可能就不會被探索到。第二是symbolic execution既有的問題，當它遇到大量迴圈如strcmp函式，會產生大量路徑，而且很難找到能夠離開的路徑，我們的演算法也會遇到這個問題，在部分的實驗中顯示了仍然有可能被困住而沒有繼續增加覆蓋率，這只能依靠結合其他技術來獲得解決。最後是CFG的問題，當靜態分析發生錯誤，如產生出的CFG有部分不正確，或是被混淆代碼(obfuscated code)等等可能的因素，那演算法對於模擬計算出的期望值就可能沒有效果，這時就只能依靠路徑的已執行程式碼區塊數量來判斷，演算法的效果會變差。

目前的演算法使用的是較輕量級的價值評估函式，並沒有運用太多的domain knowledge，如果能結合對敏感函式或危險行為的偵測，在漏洞尋找上相信能有更大的成效；而我們實作採用的框架屬於較易於開發但小型的平台，如能移植到較大且完整的系統如s2e中，應能支援更大且複雜的程式。

\newpage

\printbibliography[title={References}]

\newpage

\begin{appendices}
\chapter{實驗數據}

下列表格為4.3節圖表的數據，其中round表示執行為第幾次step時，表格內數字為basic blocks涵蓋數量，最下方一行則是終止時的round數和basic blocks涵蓋數量。

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{cpp-markdown \& cp 長時間執行數據}
\label{testMethodB}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{cpp-markdown} & \phantom{abc} & \multicolumn{3}{c}{cp} \\ \cmidrule{2-4} \cmidrule{6-8}
round      & BFS   & DFS  & MCTS & & BFS   & DFS & MCTS     \\ \midrule
100        & 47    & 47   & 47   & & 24    & 47  & 38       \\
500        & 196   & 205  & 199  & & 50    & 164 & 119      \\
1000       & 385   & 376  & 349  & & 92    & 178 & 202      \\
2000       & 459   & 497  & 477  & & 126   & 186 & 331      \\
5000       & 519   & 572  & 541  & & 196   & 222 & 462      \\
10000      & 560   & 579  & 559  & & 215   & 222 & 573      \\
20000      & 629   & 579  & 593  & & 226   & 222 & N/A      \\
& 102k/661 & 110k/588 & 143k/606 & & 20k/226 & 64k/222 & 17k/581     \\ \bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{echo \& gif2png 長時間執行數據}
\label{testMethodC}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{echo} & \phantom{abc} & \multicolumn{3}{c}{gif2png} \\ \cmidrule{2-4} \cmidrule{6-8}
round      & BFS   & DFS  & MCTS & & BFS   & DFS & MCTS     \\ \midrule
100        & 27    & 34   & 37   & & 23    & 14  & 26       \\
500        & 43    & 52   & 67   & & 49    & 34  & 70       \\
1000       & 57    & 57   & 71   & & 53    & 64  & 96       \\
2000       & 77    & 71   & 79   & & 58    & 64  & 107      \\
5000       & 105   & 84   & 92   & & 61    & 64  & 107      \\
10000      & 118   & 87   & 93   & & 63    & 64  & 107      \\
20000      & 129   & 87   & 102  & & 73    & 64  & 107      \\
& 21k/129 & 94k/87 & 26k/103 & & 24k/74 & 64k/64 & 79k/107  \\ \bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{hostname \& ls 長時間執行數據}
\label{testMethodC}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{hostname} & \phantom{abc} & \multicolumn{3}{c}{ls} \\ \cmidrule{2-4} \cmidrule{6-8}
round      & BFS   & DFS  & MCTS & & BFS   & DFS & MCTS     \\ \midrule
100        & 19    & 35   & 25   & & 38    & 44  & 35       \\
500        & 57    & 61   & 95   & & 74    & 125 & 128      \\
1000       & 60    & 61   & 128  & & 98    & 156 & 169      \\
2000       & 61    & 61   & 146  & & 133   & 158 & 241      \\
5000       & 63    & 61   & 184  & & 185   & 198 & 344      \\
10000      & 64    & 61   & 184  & & 201   & 198 & 493      \\
20000      & 65    & 61   & 184  & & N/A   & 198 & 646      \\ 
& 25k/65 & 119k/61 & 65k/184 & & 12k/209 & 78k/198 & 21k/652 \\ \bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{mkdir \& ps 長時間執行數據}
\label{testMethodC}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{mkdir} & \phantom{abc} & \multicolumn{3}{c}{ps} \\ \cmidrule{2-4} \cmidrule{6-8}
round      & BFS   & DFS  & MCTS & & BFS   & DFS & MCTS     \\ \midrule
100        & 24    & 49   & 40   & & 32    & 27  & 29       \\
500        & 76    & 71   & 96   & & 55    & 118 & 72       \\
1000       & 95    & 79   & 97   & & 84    & 185 & 83       \\
2000       & 110   & 82   & 120  & & 107   & 185 & 96       \\
5000       & 126   & 82   & 389  & & 116   & 185 & 107      \\
10000      & 133   & 82   & 532  & & 128   & 185 & 271      \\
20000      & 154   & 82   & 568  & & N/A   & 185 & N/A       \\
& 34k/171 & 156k/82 & 35k/572 & & 11k/131 & 91k/185 & 15k/431 \\ \bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\ra{1.3}
\centering
\caption{readelf \& touch 長時間執行數據}
\label{testMethodD}
\begin{tabular}{@{}llllllllllll@{}} \toprule
             & \multicolumn{3}{c}{readelf} & \phantom{abc} & \multicolumn{3}{c}{touch} \\ \cmidrule{2-4} \cmidrule{6-8}
round      & BFS   & DFS  & MCTS & & BFS   & DFS & MCTS     \\ \midrule
100        & 39    & 41   & 43   & & 24    & 48  & 39       \\
500        & 95    & 124  & 103  & & 71    & 117 & 141      \\
1000       & 113   & 234  & 163  & & 91    & 161 & 218      \\
2000       & 133   & 323  & 280  & & 116   & 184 & 286      \\
5000       & 177   & 393  & 352  & & 142   & 222 & 307      \\
10000      & 185   & 415  & 421  & & 161   & 222 & 334      \\
20000      & 201   & 464  & 456  & & 175   & 222 & 339      \\ 
& 22k/205 & 35k/466 & 90k/652  & & 24k/182 & 65k/222 & 139k/340 \\ \bottomrule
\end{tabular}
\end{table}

\end{appendices}

\end{document}
